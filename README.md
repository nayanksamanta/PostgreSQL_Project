# PostgreSQL_Project
SQL analysis of the DVD_rental database using PostgreSQL. Includes queries for revenue tracking, customer behavior, and inventory performance.

# Project Overview
This project features a comprehensive suite of 30 PostgreSQL queries designed to extract actionable insights from a mock DVD rental database. Utilizing the industry-standard Sakila/Pagila schema, the project demonstrates proficiency in relational database management, spanning from basic data retrieval to advanced analytical techniques like window functions, complex joins, and automated triggers.

# Objective
The primary goal of this project is to simulate real-world business intelligence tasks for a retail environment. Specifically, it aims to:

1. Analyze Customer Behavior: Identify high-value customers and rental frequency patterns.
2. Inventory Management: Track film popularity, category performance, and stock availability.
3. Financial Reporting: Calculate revenue streams, late return impacts, and yearly growth.
4. Database Optimization: Implement performance-tuning strategies through indexing and automated logging via PL/pgSQL triggers.

# Project Queries


### 1. List all films with their titles and release years.
```sql
SELECT title, release_year FROM film ORDER BY title ASC;
```

### 2. Find the total number of films in the database.
```sql
SELECT COUNT(*) AS total_films FROM film;
```

### 3. Show the names of all customers who rented at least one film.
```sql
SELECT DISTINCT c.first_name, c.last_name FROM customer c JOIN rental r ON c.customer_id = r.customer_id;
```

### 4. Retrieve the titles of films in the “Action” category.
```sql
SELECT 
    f.title
FROM film f
JOIN film_category fc ON f.film_id = fc.film_id
JOIN category c ON fc.category_id = c.category_id
WHERE c.name = 'Action'
ORDER BY f.title;
```

### 5. Count how many films belong to each category.
```sql
SELECT 
    c.name AS category_name, 
    COUNT(fc.film_id) AS total_films
FROM category c
JOIN film_category fc ON c.category_id = fc.category_id
GROUP BY c.name
ORDER BY total_films DESC;
```

### 6. Display the top 5 longest films by length.
```sql
SELECT 
    title, 
    length 
FROM film
ORDER BY length DESC
LIMIT 5;
```

### 7. Find the number of rentals made in January 2006.
```sql
SELECT COUNT(*) AS january_rentals
FROM rental
WHERE rental_date >= '2006-01-01 00:00:00' 
  AND rental_date <= '2006-01-31 23:59:59';
```

### 8. Show all films that have rental rates greater than $3.
```sql
SELECT 
    title, 
    rental_rate
FROM film
WHERE rental_rate > 3
ORDER BY rental_rate DESC;
```

### 9. List all distinct cities where customers live.
```sql
SELECT DISTINCT 
    ci.city
FROM customer cu
JOIN address a ON cu.address_id = a.address_id
JOIN city ci ON a.city_id = ci.city_id
ORDER BY ci.city ASC;
```

### 10. Find the staff members who processed rentals.
```sql
SELECT DISTINCT 
    s.first_name, 
    s.last_name, 
    s.email
FROM staff s
JOIN rental r ON s.staff_id = r.staff_id
ORDER BY s.last_name;
```

### 11. Find the top 10 films by number of rentals.
```sql
SELECT 
    f.title, 
    COUNT(r.rental_id) AS rental_count
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
GROUP BY f.film_id, f.title
ORDER BY rental_count DESC
LIMIT 10;
```

### 12. Show the revenue generated by each film (sum of payments).
```sql
SELECT 
    f.title, 
    SUM(p.amount) AS total_revenue
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
JOIN payment p ON r.rental_id = p.rental_id
GROUP BY f.film_id, f.title
ORDER BY total_revenue DESC; 
```

### 13. List customers who rented more than 20 films
```sql
SELECT 
    c.first_name, 
    c.last_name, 
    COUNT(r.rental_id) AS rental_count
FROM customer c
JOIN rental r ON c.customer_id = r.customer_id
GROUP BY c.customer_id, c.first_name, c.last_name
HAVING COUNT(r.rental_id) > 20
ORDER BY rental_count DESC;
```

### 14. Find the average rental duration for each category. in pgsql
```sql
SELECT 
    c.name AS category_name,
    ROUND(AVG(f.rental_duration), 2) AS avg_rental_duration
FROM category c
JOIN film_category fc ON c.category_id = fc.category_id
JOIN film f ON fc.film_id = f.film_id
GROUP BY c.name;	
```

### 15. Display films that were rented but never returned late.
#### All films that have been rented
```sql
SELECT DISTINCT f.title
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id

EXCEPT
```
#### Films that have been returned late at least once
```sql
SELECT DISTINCT f.title
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
WHERE EXTRACT(DAY FROM (r.return_date - r.rental_date)) > f.rental_duration;
```

### 16. Identify the most popular film category by rental_rate.
```sql
SELECT 
    c.name AS category_name,
    ROUND(AVG(f.rental_rate), 2) AS average_rental_rate
FROM category c
JOIN film_category fc ON c.category_id = fc.category_id
JOIN film f ON fc.film_id = f.film_id
GROUP BY c.name
ORDER BY average_rental_rate DESC
LIMIT 1;
```

### 17. Show the monthly rental count trend for 2005–2006.
```sql
SELECT 
    TO_CHAR(rental_date, 'YYYY-MM') AS rental_month,
    COUNT(rental_id) AS total_rentals
FROM rental
WHERE rental_date >= '2005-01-01' AND rental_date <= '2006-12-31'
GROUP BY rental_month
ORDER BY rental_month;
```

### 18. Find customers who rented films from more than 5 categories. in simple pgsql
```sql
SELECT 
    c.first_name, 
    c.last_name, 
    COUNT(DISTINCT fc.category_id) AS total_categories
FROM customer c
JOIN rental r ON c.customer_id = r.customer_id
JOIN inventory i ON r.inventory_id = i.inventory_id
JOIN film_category fc ON i.film_id = fc.film_id
GROUP BY c.customer_id, c.first_name, c.last_name
HAVING COUNT(DISTINCT fc.category_id) > 5
ORDER BY total_categories DESC;
```

### 19. List films that were rented by customers from Canada.
```sql
SELECT DISTINCT 
    f.title, country
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
JOIN customer c ON r.customer_id = c.customer_id
JOIN address a ON c.address_id = a.address_id
JOIN city ct ON a.city_id = ct.city_id
JOIN country co ON ct.country_id = co.country_id
WHERE co.country = 'Canada'
ORDER BY f.title;
```

### 20. Show the top 5 customers by total payment amount.
```sql
SELECT 
    c.first_name, 
    c.last_name, 
    SUM(p.amount) AS total_spent
FROM customer c
JOIN payment p ON c.customer_id = p.customer_id
GROUP BY c.customer_id, c.first_name, c.last_name
ORDER BY total_spent DESC
LIMIT 5;
```


### 21. Use a window function to rank films by rental frequency.
```sql
SELECT 
    f.title,
    COUNT(r.rental_id) AS rental_count,
    RANK() OVER (ORDER BY COUNT(r.rental_id) DESC) AS rental_rank
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
GROUP BY f.film_id, f.title
ORDER BY rental_rank;
```

### 22. Create a CTE to calculate monthly revenue and display the top 3 months
```sql
WITH MonthlyRevenue AS (
    SELECT 
        TO_CHAR(payment_date, 'YYYY-MM') AS revenue_month,
        SUM(amount) AS total_revenue
    FROM payment
    GROUP BY revenue_month
)
SELECT 
    revenue_month, 
    total_revenue
FROM MonthlyRevenue
ORDER BY total_revenue DESC
LIMIT 3;
```

### 23. Find films that generated revenue above the overall average.
```sql
WITH FilmRevenue AS (
    SELECT f.title, SUM(p.amount) AS revenue
    FROM film f
    JOIN inventory i ON f.film_id = i.film_id
    JOIN rental r ON i.inventory_id = r.inventory_id
    JOIN payment p ON r.rental_id = p.rental_id
    GROUP BY f.title
)
SELECT * FROM FilmRevenue 
WHERE revenue > (SELECT AVG(revenue) FROM FilmRevenue);
```
### 24. Write a query to calculate customer lifetime value (total payments per customer).
```sql
SELECT 
    c.customer_id,
    c.first_name,
    c.last_name,
    c.email,
    SUM(p.amount) AS lifetime_value,
    COUNT(p.payment_id) AS total_transactions
FROM customer c
JOIN payment p ON c.customer_id = p.customer_id
GROUP BY c.customer_id, c.first_name, c.last_name, c.email
ORDER BY lifetime_value DESC;
```

### 25. Identify films that were rented in consecutive months.
#### Step 1: Get unique film + month combinations
```sql
WITH MonthlyFilmRentals AS (
    SELECT DISTINCT
        f.film_id,
        f.title,
        DATE_TRUNC('month', r.rental_date) AS rental_month
    FROM film f
    JOIN inventory i ON f.film_id = i.film_id
    JOIN rental r ON i.inventory_id = r.inventory_id
),
ConsecutiveCheck AS (
```
#### Step 2: Look at the previous month for that specific film
```sql
    SELECT 
        title,
        rental_month,
        LAG(rental_month) OVER (PARTITION BY film_id ORDER BY rental_month) AS prev_month
    FROM MonthlyFilmRentals
)
```
#### Step 3: Filter for rows where the current month is exactly 1 month after the previous
```sql
SELECT DISTINCT title
FROM ConsecutiveCheck
WHERE rental_month = prev_month + INTERVAL '1 month';
```
### 26. Create a materialized view showing film popularity by category.
#### --CREATING MATERIALIZED VIEW--
```sql
CREATE MATERIALIZED VIEW film_category_popularity AS
SELECT 
    c.name AS category_name,
    f.title,
    COUNT(r.rental_id) AS total_rentals,
    RANK() OVER (PARTITION BY c.name ORDER BY COUNT(r.rental_id) DESC) AS rank_in_category
FROM category c
JOIN film_category fc ON c.category_id = fc.category_id
JOIN film f ON fc.film_id = f.film_id
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
GROUP BY c.name, f.title;

SELECT * FROM film_category_popularity WHERE rank_in_category <= 3;
REFRESH MATERIALIZED VIEW film_category_popularity;
```

### 27. Write a stored procedure to calculate revenue for a given film ID.
```sql
CREATE OR REPLACE PROCEDURE get_film_revenue(
    p_film_id INT, 
    INOUT p_revenue NUMERIC(10,2) DEFAULT 0
)
LANGUAGE plpgsql
AS $$
BEGIN
    -- Calculate the total revenue for the specific film_id
    SELECT COALESCE(SUM(p.amount), 0)
    INTO p_revenue
    FROM payment p
    JOIN rental r ON p.rental_id = r.rental_id
    JOIN inventory i ON r.inventory_id = i.inventory_id
    WHERE i.film_id = p_film_id;

    -- Optional: Raise a notice for debugging/logging
    RAISE NOTICE 'Total revenue for film ID % is $%', p_film_id, p_revenue;
END;
$$;

CALL get_film_revenue(1, 0);
```

### 28. Build a trigger that logs whenever a rental is returned late.

#### --STEP:1 Create the Log Table
```sql
CREATE TABLE late_return_log (
    log_id SERIAL PRIMARY KEY,
    rental_id INT,
    customer_id INT,
    expected_return TIMESTAMP,
    actual_return TIMESTAMP,
    days_late INT,
    log_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
#### --STEP:2 Create the Trigger Function
```sql
CREATE OR REPLACE FUNCTION log_late_return()
RETURNS TRIGGER AS $$
DECLARE
    v_rental_duration INT;
    v_expected_return TIMESTAMP;
BEGIN
    -- Get the allowed rental duration for this specific film
    SELECT f.rental_duration INTO v_rental_duration
    FROM film f
    JOIN inventory i ON i.film_id = f.film_id
    WHERE i.inventory_id = OLD.inventory_id;

    v_expected_return := OLD.rental_date + (v_rental_duration || ' days')::INTERVAL;

    -- Check if the return is happening now and if it is past the expected date
    IF (NEW.return_date IS NOT NULL AND NEW.return_date > v_expected_return) THEN
        INSERT INTO late_return_log (rental_id, customer_id, expected_return, actual_return, days_late)
        VALUES (
            NEW.rental_id, 
            NEW.customer_id, 
            v_expected_return, 
            NEW.return_date,
            EXTRACT(DAY FROM (NEW.return_date - v_expected_return))
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--STEP:3 Create the Trigger
CREATE TRIGGER trg_late_return
AFTER UPDATE OF return_date ON rental
FOR EACH ROW
EXECUTE FUNCTION log_late_return();
```
### 29. Partition rentals by year and calculate yearly revenue.
```sql
SELECT 
    EXTRACT(YEAR FROM p.payment_date) AS rental_year,
    SUM(p.amount) AS yearly_revenue,
    COUNT(p.payment_id) AS total_transactions,
    ROUND(AVG(p.amount), 2) AS avg_transaction_value
FROM payment p
GROUP BY rental_year
ORDER BY rental_year DESC;
```
### 30. Optimize a query using indexes to speed up film search by title.
#### --1. The Problem: Unoptimized Search
```sql
SELECT film_id, title, release_year
FROM film
WHERE title = 'ACADEMY DINOSAUR';
```
#### --2. The Solution: Creating a B-Tree Index
```sql
CREATE INDEX idx_film_title ON film(title);
```
#### --3. Verifying the Optimization
```sql
EXPLAIN ANALYZE
SELECT film_id, title, release_year
FROM film
WHERE title = 'ACADEMY DINOSAUR';
```
#### --4. Handling Partial Searches (LIKE)
#### -- Enable the extension
```sql
CREATE EXTENSION pg_trgm;
```

#### -- Create a GIST index for pattern matching
```sql
CREATE INDEX idx_film_title_trgm ON film USING GIST (title gist_trgm_ops);
```


# Key Findings
### After executing the 30-step analysis, several critical business patterns emerged:

 Content Popularity: The library's "Action" and "Animation" categories consistently drive the highest rental volumes, while premium-tier films ($4.99) account for the majority of total revenue despite being a smaller portion of the inventory.
 Customer Loyalty: A core segment of "Power Users" (those renting 20+ films) represents a significant percentage of recurring revenue, suggesting that a loyalty program could further increase retention.
 Operational Bottlenecks: Analysis of return dates revealed that a measurable percentage of films are returned late, highlighting a clear opportunity for revenue recovery through automated late-fee logging.
 Market Concentration: Customer data is geographically diverse, but revenue is concentrated in specific urban hubs, suggesting targeted marketing locations for future physical kiosks or stores.

# Reports Generated
### The project produces the following business-ready reports:

 Top 10 Performance Report: A list of the most rented films and their total contribution to store earnings.
 Inventory Health Audit: A breakdown of film counts by category and rating to identify gaps in the collection.
 Monthly/Yearly Revenue Statements: Comparative financial data partitioned by year to track growth trends.
 Staff Performance Log: A summary of transactions handled by each staff member for productivity tracking.

# Conclusion
This project successfully demonstrates the power of PostgreSQL in managing a complex, interconnected retail ecosystem. By transforming raw transactional data into structured reports, we provided deep insights into inventory lifecycle and customer habits. The implementation of indexes and automated triggers ensures that the database remains not only a repository of information but a high-performance tool capable of scaling with business needs. This suite of queries serves as a robust framework for any subscription or rental-based business model.
